Git è un software creato per la gestione dei file di un progetto. Il software permette di condividere i file e tenere traccia dello storico per sapere quali modifiche sono state attuate e dove. 

\section{Creazione della directory}
La prima cosa da fare è configurare il profilo git attraverso l'impostazione del proprio nome e di una email: \texttt{git config --<mode> user.name "myusername"} e \texttt{git config --<mode> user.email "myemail@.com"}.
<mode> può avere due valori: global, che sarà salvata nella cartella /.config, e local che sarà relativa alla directory corrente.

Tutti i file saranno caricati in una cartella locale \emph{.git}, detta \emph{directory}. Questa è nascosta di default ma può essere mostrata scrivendo al terminale i comandi: ls -al oppure ll. 
Le prime azioni da fare sono
\begin{enumerate} 
    \item Creazione della cartella: \texttt{git init}. 
    \item Preparazione del materiale da aggiungere alla cartella git: \texttt{git add}
    \item Aggiunta del materiale alla cartella git: \texttt{git commit -m "messaggio"}. Il messaggio è obbligatorio e può essere lungo al massimo 50 caratteri. Si tratta di un riassunto sul materiale che sarà aggiunto. Il messaggio può essere prodotto anche da un editor di testo omettendo i caratteri -m e "messaggio".
\end{enumerate}
Ognuno di questi passi consegue una modifica nella directory che può essere visualizzata attraverso il comando \texttt{git status}. 
Terminata l'ultima operazione, ovvero l'invio del commitment, lo stato finale è visibile  attraverso il comando \texttt{git log}, che disporrà le informazioni generali dell'utente (nome, email, data) seguiti dall'hash, una stringa di caratteri identificativa per ogni commitment.

Quando si lavora su un progetto è bene suddividere il compito tra i partecipanti, che lavoreranno in parallelo. Ciò è possibile in git creando i \emph{branch}. Ogni branch, rispetto a quello di default che è il master (quando si crea la directory è specificato) è autonomo dagli altri. 
Un branch è creato attraverso il comando: \texttt{git branch nome\_nuovo\_branch}; per muoversi da un branch ad un altro: \texttt{git switch branch\_verso\_cui\_switchare}.
Le operazioni possono essere eseguite contemporanemente: \texttt{git switch -c nome\_nuovo\_branch}. 

Quando il lavoro su un branch è terminato per aggiungerne le modifiche ad un altro branch il comando è  \texttt{git merge nome\_branch\_dacui\_merge}. \emph{Il merge è fatto rispetto al branch che ha invocato la funzione di merging, quindi fare molta attenzione sul branch rispetto al quale è stato invocato il comando}. 
La struttura ramificata dei vari branch è visibile atraverso il comando \texttt{git log --all --graph}.
Supponiamo di avere due branch, branch1 e branch2, entrambi che hanno modificato e aggiunto il file1 scrivendo git add file1 e git commit -m "messaggio generico". 
Quando il branch1 cercherà di fare il merge ci sarà un errore: siamo entrati nella modalità di conflitto. 
Il conflitto è risolto lasciando solo la parte del file che vogliamo effettivamente mergare, le altre vanno cancellate insieme a tutti i caratteri insertiti da git per mostrare dove era presente il conflitto, ad esempio >> oppure la scritta HEAD in riferimento al branch in uso che ha invocato il merge.
Una volta risolto il conflitto bisogna nuovamente scrivere \texttt{git add nome\_file} e \texttt{git commit} ove non è necessario scrivere un commento perchè sarà aggiunto automaticamente da git rigurdante la posizione del conflitto e cosa è stato aggiunto e cosa tolto. 

I commitment più importanti sono visibili da parte degli altri utenti attraverso i tag: \texttt{git tag nome\_tag parte\_hash}.
La lista completa dei tag in una directory sono visibili scrivendo \texttt{git tag}.

Ogni comando visto finora è reverziabile da etichette specifiche, come per l'hash per i commitment.
Ad esempio l'HEAD è un'etichetta associabile ad un commitment.
Di default  riguarda l'ultimo commitment fatto e viene cambiato implicitamente quando si applica il comando switch, oppure quando si fa un commitment; può essere modificato facendolo puntare ad uno dei commitment dello storico scrivendo \texttt{git checkout commit\_hash}. 
Quando l'HEAD sta puntando (le etichette sono a tutti gli effetti dei puntatori) ad un commitment che non è l'ultimo in ordine cronologico, ovvero quello puntato dal branch corrente, si dice che l'HEAD è \emph{detached}.

% apporfondire come creare una repository remota di git da terminale 
\section{Directory in remoto}
I commitment visti fin'ora sono in locale: per condividerli in rete è necessario pubblicare la directory in remoto.
Per aggiungere la repository i comandi sono \texttt{git remote add nome\_ref\_repository url\_repository}, il nome del riferimento alla directory è del tutto arbitrario, solitamente si usa origin; ad esempio git remote add origin https//\[...\]. 
Il contenuto di ogni riferimento è visibile attraverso il comando \texttt{git remote -v}. Un possibile output è origin https://\[...\] (push) https://\[...\] (fetch) che fornisce le informazioni sull'indirizzo della pagina dove saranno inviati i cambiamenti e da dove saranno presi poiché altre persone potrebbero aver cambiato la repository online.

\texttt{git push riferimento\_directory\_remota riferimento\_branch} con il riferimento del branch da cui pushare che è stato creato attraverso il comando tag. 
Il cambiamento è visibile dall'output del comando log che tra parentesi tonde evidenzia l'accostamento nome branch remoto con il nome del branch locale separati da \\.

Ad esempio git push origin master. \emph{E' buona norma che il branch locale abbia la stessa tag della repository remota.}
\emph{I conflitti devono essere risolti in locale prima di fare una qualsiasi push su una directory remota}.


\texttt{git reset} \texttt{git reset --hard} Cancella tutte le modifiche dei file che non sono stati ancora committati.

Immaginiamo che ci siano due utenti, utente1 e utente2 entrambi su due diversi branch, rispettivamente branch1 e branch2. 
L'utente1, che lavora su un branch diverso dal due, scrive sul  file X, fa il commit e aggiunge la modifica alla repository online.
L'utente2 fa lo stesso del primo, ma invece di aggiungere il file alla repository online usando il comando add, usa push.
Ciò crea un conflitto, infatti l'utente 2 sta cercando di inviare un commitment inconscio del fatto che l'altro utente abbia dei file diversi, ad esempio quello X. 
Come fa git ad accettarne quando ci sono delle divergenze? Semplice: non può. 
Per risolvere il conflitto è necessario ottenere le informazioni rigurdanti le modifiche operate dal primo utente che saranno aggiunte in automatico da git, nell'esempio scaricando il  file X.
Un primo modo per far si che ciò accada  è scrivere \texttt{git pull remote\_ref\_name ref} che oltre a scaricare il materiale mancante attua  un merge. 
In l'operazione è rischiosa in quanto aggiunge al materiale che disponiamo delle modifiche che non vorremmo fossero adottate implicitamente. 
Per questo motivo sono presenti delle versioni che forniscono un controllo maggiore, ad esempio \texttt{git config pull.ff -only} che attua un merge senza il commit e solo nel caso sia rispetto a del materiale, quello scaricato, più avanzato di quello di partenza, altrimenti termina segnalando un errore, oppure \texttt{git pull --rebase true} che attua il merge aggiungendo allo storico del branch che ha invocato il comando i commit del branch origin/master, ovvero quello remoto. 
Difatto mentre con il solo pull la situazione è 
- o - o - o - H - A - B - C - X (master)
               \             /
                P - Q - R --- (origin/master)
con il pull --rebase è
- o - o - o - H - P - Q - R - A' - B' - C' (master)
                          |
                          (origin/master)
Difatto entrambi hanno lo stesso risultato, ma nel primo caso lo storico non è aggiornato delle modifiche dell'origin/master  come invece avviene nel secondo, che quindi fornisce la possibilità di una maggior analisi anche in virtù del fatto che attraverso il comando checkout si può modificare l'HEADER permettendo di raggiungere R che invece era impossibile da puntare nel primo caso.
In questo senso, se si vuole distingure la fase di scaricamento da quella di merge è utile il comando \texttt{git fetch remote\_ref\_name ref} che scarica solo il materiale più aggiornato. 
In generale vale la regola: \emph{ogni volta che è presente una divergenza tra i materiali di due o più utenti è \underline{necessario} ristabilire l'ordine localmente per poi applicare le modifiche in remoto, mai l'incontrario.}. 
Alcune note: 
\begin{itemize}
    \item Il branch master non è quello principale, in realtà qualunque branch può essere considerato quello principale, l'unica differenza sta nel fatto che il master è quello di default di git.
    \item I branch sono da pensare come delle etichette che rispetto alle quali si hanno diversi percorsi sull'evoluzione del progetto, ma non come dei rami di un albero che una volta creati saranno per sempre indipendenti dal tronco, in tal senso un branch può effetuare un merge. 
    \item Il merge non causa l'eliminazione di alcun branch, è però buona norma eliminare il branch quando è stato mergiat: \texttt{git branch nome\_branch --delete}.
\end{itemize}

\subsection{Come iniziare}
Per iniziare si può clonare una repository online, il comando è semplice:
\texttt{git clone url\_repository} che sintetizza i comandi:
\texttt{mkdir nome\_repo cd nome\_repo git init git remote add origin url\_repo git pull}.

\subsection{Recuperare directory cancellate}
Se si è usato il comando rm per cancellare i file e non si è ancora fatto un add git, il comando \texttt{git checkout --filename}. 
Qualora si volesse ristabilire lo stato iniziale della ripository basta non specificare \texttt{--filename} scrivendo soltanto \texttt{git checkout}.
